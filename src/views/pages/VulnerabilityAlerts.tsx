import {
  defineComponent,
  onMounted,
  reactive,
  watch
} from '@vue/composition-api'
import { useQuery } from '@vue/apollo-composable'
import gql from 'graphql-tag'
import { __sync } from 'babel-plugin-vue-jsx-modifier/lib/modifiers'

export const VulnerabilityAlerts = defineComponent({
  setup(_, { root }) {
    const state = reactive({
      loading: false,
      allVunerabilityAlerts: [] as any,
      options: {} as any,
      headers: [
        {
          text: 'Repository',
          align: 'start',
          sortable: true,
          value: 'name'
        },
        {
          text: 'Privacy',
          value: 'isPrivate',
          sortable: false
        },
        {
          text: 'Vulnerability Alerts',
          value: 'vulnerabilityAlerts',
          sortable: false
        }
      ],
      totalCount: 0,
      lastPage: 1,
      pageInfo: {
        endCursor: null,
        startCursor: null
      }
    })

    const vulnerabilityAlerts = useQuery(
      gql`
        query repositoryOwner(
          $first: Int
          $last: Int
          $after: String
          $before: String
        ) {
          repositoryOwner(login: "joaomede") {
            repositories(
              first: $first
              last: $last
              after: $after
              before: $before
              orderBy: { field: UPDATED_AT, direction: DESC }
            ) {
              totalCount
              pageInfo {
                endCursor
                startCursor
              }
              edges {
                node {
                  name
                  isPrivate
                  updatedAt
                  vulnerabilityAlerts(first: 20) {
                    edges {
                      node {
                        id
                        securityVulnerability {
                          severity
                        }
                        createdAt
                        dismisser {
                          name
                        }
                        securityAdvisory {
                          references {
                            url
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `,
      {
        first: 10,
        last: null,
        after: null,
        before: null
      }
    )

    watch(
      () => state.options,
      async () => {
        await loadVulnerabilityAlerts()
      }
    )

    onMounted(() => {
      root.$nextTick(() => {
        if (root.cProfile.login === undefined) {
          root.$router.push('/login')
        }

        vulnerabilityAlerts.onResult((e) => {
          mapDataResult(e?.data.repositoryOwner.repositories)
        })
      })
    })

    async function loadVulnerabilityAlerts() {
      state.loading = true
      root.cLoading.on()
      try {
        const { data } = await vulnerabilityAlerts.refetch({
          first:
            state.options.page > state.lastPage ||
            state.options.page === state.lastPage
              ? state.options.itemsPerPage
                ? state.options.itemsPerPage
                : 10
              : null,
          last:
            state.options.page < state.lastPage
              ? state.options.itemsPerPage
                ? state.options.itemsPerPage
                : 10
              : null,
          after:
            state.options.page > state.lastPage
              ? state.pageInfo.endCursor
              : null,
          before:
            state.options.page < state.lastPage
              ? state.pageInfo.startCursor
              : null
        })

        mapDataResult(data.repositoryOwner.repositories)
        state.loading = false
        root.cLoading.off()
      } catch (error) {
        state.loading = false
        root.cLoading.off()
        root.notify(error.message, 'red', 8)
      }
    }

    /**
     * Map Result List
     *
     * @param {*} data
     */
    function mapDataResult(data) {
      state.allVunerabilityAlerts = []
      data.edges.map((e) => {
        state.allVunerabilityAlerts.push({
          ...e.node,
          vulnerabilityAlerts: e.node.vulnerabilityAlerts.edges.length > 0
        })
      })
      state.totalCount = data.totalCount
      state.pageInfo = data.pageInfo
      state.lastPage = state.options.page
    }

    return () => {
      return (
        <v-card height={'100%'}>
          <v-card-title>Vulnerability Alerts</v-card-title>
          <v-data-table
            fixed-header={true}
            class={'ma-auto elevation-1'}
            headers={state.headers}
            items={state.allVunerabilityAlerts}
            options={__sync(state.options)}
            itemsPerPage={10}
            serverItemsLength={state.totalCount}
            loading={state.loading}
            footer-props={{ 'items-per-page-options': [10, 25] }}
            scopedSlots={{
              'item.isPrivate': ({ item }) => {
                if (item.isPrivate) {
                  return (
                    <v-icon large color={'red'}>
                      fas fa-lock
                    </v-icon>
                  )
                } else {
                  return (
                    <v-icon large color={'green'}>
                      fas fa-lock-open
                    </v-icon>
                  )
                }
              },
              'item.vulnerabilityAlerts': ({ item }) => {
                if (item.vulnerabilityAlerts) {
                  return (
                    <v-icon large color={'red'}>
                      fas fa-exclamation
                    </v-icon>
                  )
                } else {
                  return (
                    <v-icon large color={'green'}>
                      fas fa-thumbs-up
                    </v-icon>
                  )
                }
              }
            }}
          ></v-data-table>
        </v-card>
      )
    }
  }
})
